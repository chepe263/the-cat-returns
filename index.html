<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>The cat runs away.</title>
    <script src="https://unpkg.com/konva@2.4.2/konva.min.js"></script>

</head>
<body>
    <div id="container"></div>
    <script>
		var stage_width = 800; //window.innerWidth;
		var stage_height = 600; //window.innerHeight;
		var size_ratio = stage_width / stage_height;
		var max_circle_x = 10 ;
		var max_circle_y = 6 ;
		var cat_current_circle_id = '';
		var left_padding = 70; // space at the left side of the board
		var top_padding = 70; // space at the left side of the board
		var top_margin_factor = 1.3;  //margin between circles
		var left_margin_factor = 1.1; //margin between circles	
		var cat_width = 50;
		var cat_height = 50 ;
		var radius = 35 ; //circle_radius
		var circle_map = [];
		var game = {
			'result': {
				'win': 1
				,'lose': 0
				,'tie': -1
			}
			,'user':{
				'human': 1
				,'cpu': 0
			}
		};
		var move_directions = {
			'up':0
			,'down':1
			,'left':2
			,'right':3
			,'up_right':4
			,'up_left':5
			,'down_right':6
			,'down_left':7
		}
		
		function end_game(result, user){
			layer.off('click');
			console.log('end_game!!! Result, user', result, user);
		}
		
		function caculate_cat_position(to_circle_y, to_circle_x){
			if(typeof to_circle_x == "number" && typeof  to_circle_y == "number" ){
				to_circle_y = ".circle_" + to_circle_y + "_" + to_circle_x;
			}
			
			var shape = layer.find(to_circle_y)[0];
			var parent = shape.getParent();
			return {
				x: parent.x() + shape.x() - (cat_width/2),
				y: parent.y() +  shape.y()  - (cat_height/2),
			}
		}
		function next_cat_move(current_x, current_y){
			if (current_x == undefined && current_y == undefined){
				var cat_cords = cat_current_circle_id.split('_');
				current_x = parseInt(cat_cords[2] );
				current_y = parseInt(cat_cords[1] );			
			}
			var valid_movements = [];
			var invalid_movements = [];
			var exits = [];
			// out of range for next move, cat escapes!
			if(current_x == 0){
				exits.push('left');
			}
			if(current_x == max_circle_x - 1){
				exits.push('right');
			}
			if(current_y == 0){
				exits.push('up');
			}
			if(current_y == max_circle_y - 1){
				exits.push('down');
			}
			if(exits.length > 0){
				return exit_cat_move(exits);
			}
			// END out of range for next move, cat escapes!
			var cat_directions = [
				 {finisher: false, priority: 0, direction: move_directions.up_right, x: current_x +1, y: current_y - 1, 'label':'up, right ↗'}
				,{finisher: false, priority: 1, direction: move_directions.down_left, x: current_x - 1, y: current_y + 1, 'label':'down, left ↙'}
				,{finisher: false, priority: 0, direction: move_directions.up_left, x: current_x - 1, y: current_y - 1, 'label':'up, left ↖'}
				,{finisher: false, priority: 1, direction: move_directions.down_right, x: current_x + 1, y: current_y +1, 'label':'down, right ↘'}
				,{finisher: false, priority: 0, direction: move_directions.right, x: current_x +1, y: current_y, 'label':'right →'}
				,{finisher: false, priority: 0, direction: move_directions.up, x: current_x, y: current_y - 1, 'label':'up ↑'}
				,{finisher: false, priority: 0, direction: move_directions.left, x: current_x - 1, y: current_y, 'label':'left ←'}
				,{finisher: false, priority: 0, direction: move_directions.down, x: current_x, y: current_y + 1, 'label':'down ↓'}
				//,{x: current_x, y: current_y} //
			];
			//todo: a las direcciones del gato, cat_directions agregar prioridad
			//si el x es mayor a la mitad, tiene mas prioridad
			//si el x es menor a la mitad, tiene menos prioridad
			//igual con y
			//ordenar por prioridad, tomar el primero
			//onsole.log('cat_directions', cat_directions);
			for (var n= 0; n < cat_directions.length; n++){
				console.log(cat_directions[0].x > -1 && cat_directions[0].x < max_circle_x, cat_directions[0].x, max_circle_x);
				if ( (cat_directions[0].x > -1 && cat_directions[0].x < max_circle_x) 
				&& (cat_directions[0].y > -1 && cat_directions[0].y < max_circle_y) 
				&& (circle_map[cat_directions[n].y][cat_directions[n].x] == true)
				){
				
					/*if ( (cat_directions[0].x-1 > -1 && cat_directions[0].x+1 < max_circle_x) 
					&& (cat_directions[0].y-1 > -1 && cat_directions[0].y+1 < max_circle_y) 					
					){
						if (
						(circle_map[cat_directions[n].y][cat_directions[n].x +1] == true) ||  //right
						(circle_map[cat_directions[n].y][cat_directions[n].x -1] == true) ||  // left
						
						(circle_map[cat_directions[n].y+1][cat_directions[n].x] == true) || // down
						(circle_map[cat_directions[n].y-1][cat_directions[n].x] == true) || // up
						
						
						(circle_map[cat_directions[n].y+1][cat_directions[n].x +1] == true) ||  //down, right
						(circle_map[cat_directions[n].y +1][cat_directions[n].x -1] == true) || //down, left
						
						(circle_map[cat_directions[n].y -1 ][cat_directions[n].x +1] == true) || //up, right
						(circle_map[cat_directions[n].y -1 ][cat_directions[n].x -1] == true)    //up, left
						){
							cat_directions[n].priority  = cat_directions[n].priority + 1;
						}
					
					}*/
				
					/*if( cat_directions[n].x > Math.floor( max_circle_x / 2) ){
						//preffer right directions
						if( cat_directions[n].y > Math.floor( max_circle_y / 2) ){
							//preffer down directions						
							cat_directions[n].priority  = cat_directions[n].priority + 1;
						} else {
							//preffer up directions
							cat_directions[n].priority  = cat_directions[n].priority - 1;
						}
					} else {
						//preffer left directions
						//preffer up directions
						
					}*/
					if(cat_directions[n].x + 1 >= max_circle_x - 2 || cat_directions[n].x - 1 < 1){
						cat_directions[n].priority  = cat_directions[n].priority + 1;
					}
					if(cat_directions[n].y + 1 >= max_circle_y - 2 || cat_directions[n].y - 1 < 1){
						cat_directions[n].priority  = cat_directions[n].priority + 1;
					}
					valid_movements.push(cat_directions[n]);
				} else {
					//invalid_movements.push(cat_directions[n]);
					console.log('out of range, possible win');
				}

				
			}
			
			console.log('valids, no sort', valid_movements);
			console.log('invalids', invalid_movements);
			if(valid_movements.length > 1){
				valid_movements.sort(function(a,b){
					return a.priority -b.priority;
				});
				valid_movements.reverse();
				console.log('valids, sort', valid_movements);
				/*for(var n = 0; n < valid_movements.length; n++){
				
				}*/
			}
			return valid_movements[0]
			/*{
				x: 0
				,y: 1
			}*/
		}
		
		function exit_cat_move(moves){
			var cat_cords = cat_current_circle_id.split('_');
			var current_x = parseInt(cat_cords[2] );
			var current_y = parseInt(cat_cords[1] );
			var exit = {
				finisher: true
				, x: current_x
				, y: current_y
				, position: caculate_cat_position(current_y, current_x)
				, user: game.user.cpu
			}
			switch( moves[0]){
				case 'up': 
					exit.position.y = exit.position.y - (radius*2 * top_margin_factor);				
				break;
				case 'down': 
					exit.position.y = exit.position.y + (radius*2 * top_margin_factor);					
				break;
				case 'left': 
					exit.position.x = exit.position.x - ( (radius*2) * left_margin_factor );
				break;
				case 'right': 
					exit.position.x = exit.position.x + ( (radius*2) * left_margin_factor );
				break;
			}
			return exit;
		}
		var stage = new Konva.Stage({
		  container: 'container',
		  width: stage_width + left_padding * 2 ,
		  height: stage_height + top_padding * 2
		});
		var colors = ['white', 'white', 'lightgray']; 
		var layer = new Konva.Layer();
		////////////CLICK!
		layer.on('click touchstart', function (evt) {
			var shape = evt.target;
			if(shape.className !== "Circle" || shape.getFill() == colors[2] || cat_current_circle_id == "." + shape.getName()){
				return;
			}
			var parent = shape.getParent();
			var shape_cords = shape.getName().split('_');
			circle_map[parseInt(shape_cords[1])][parseInt(shape_cords[2])] = false;
			shape.setFill(colors[2]);
			var next_circle = next_cat_move();
			console.log("next_circle dsdsd", next_circle);
			var next_cat_pos = null;
			if(next_circle !== undefined){
				if (next_circle.finisher !== undefined && next_circle.finisher == true){
					if(next_circle.user !== undefined && next_circle.user == game.user.cpu){
						next_cat_pos = next_circle.position;
						end_game(game.result.win, game.user.cpu);				
					}
				} else {
					next_cat_pos = caculate_cat_position(next_circle.y, next_circle.x);			
				}
			}
			//console.log('next_circle, next_cat_pos', next_circle, next_cat_pos);
			if(next_circle !== undefined){
				var cat = layer.find(".cat")[0];
				cat_current_circle_id = ".circle_"  + next_circle.y + "_" + next_circle.x ;
				cat.to({
					 x: next_cat_pos.x
					,y: next_cat_pos.y
					,duration: 0.1
				});
			} else {
				end_game(game.result.win, game.user.human);	
			}
			//var abs_pos = shape.position();
					
			layer.draw();
		});
		
		
		var imageObj = new Image();

		imageObj.onload = function() {
			cat_current_circle_id = ".circle_" + (Math.floor(max_circle_y/2)-1) + "_" + (Math.floor(max_circle_x/2)-1) 
			var new_cat_pos = caculate_cat_position(cat_current_circle_id);
			var cat_img = new Konva.Image({
				 x: new_cat_pos.x,
				y: new_cat_pos.y,
				image: imageObj,
				width: 50,
				height: 50,
				name: "cat"
			  });

		  // add the shape to the layer
		  layer.add(cat_img);
		  layer.draw();

		  // add the layer to the stage
		};
		
		imageObj.src = '/bootlegcat.png';
		
		//add circles and group them
		for(var n = 0; n < max_circle_y; n++){
			var group = new Konva.Group({
				//x: left_padding + (n % 2 == 0 ? 0 : 50)
				x: left_padding 
				,y: top_padding + (radius*2 * top_margin_factor) * n
			});
			circle_map[n] = [];
			for(var i = 0; i < max_circle_x; i++){

				var circle = new Konva.Circle({
				  x: (i + 1) * (radius*2) * left_margin_factor,
				  //y: (n + 1) * radius * 2.1,
				  //y: radius * 1.1,
				  y: radius * top_margin_factor,
				  radius: radius,
				  fill: colors[i%2], //'red',
				  stroke: 'black',
				  strokeWidth: 4
				  ,name: 'circle_' + n + '_' + i //circle_y_x
				  , draggable: false
				});
				circle_map[n][i] = true;
				//layer.add(circle);
				group.add(circle);
			}
			layer.add(group);
		}

		

		
		// add the shape to the layer

		// add the layer to the stage
		stage.add(layer);
		
		
        function fitStageIntoParentContainer(e) {
			//console.log(e);
            var container = document.querySelector('#container');

            // now we need to fit stage into parent
            var containerWidth = container.offsetWidth;
			if(containerWidth >= stage_width + left_padding * 2){
				return;
			}
            // to do this we need to scale the stage
            var scale = containerWidth / (stage_width + left_padding * 2);


            stage.width(stage_width * scale);
            stage.height((stage_height + top_padding * 2) * scale);
            stage.scale({ x: scale, y: scale });
            stage.draw();
        }

        fitStageIntoParentContainer();
        // adapt the stage on any window resize
        window.addEventListener('resize', fitStageIntoParentContainer);
        window.addEventListener('onresize', fitStageIntoParentContainer);
	</script>
</body>
</html>